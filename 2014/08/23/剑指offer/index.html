<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>剑指offer 读书笔记 | 奔跑的蜗牛</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="剑指offer读书笔记，记录一些要注意的知识点。">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer 读书笔记">
<meta property="og:url" content="http://liangkai.me/2014/08/23/剑指offer/index.html">
<meta property="og:site_name" content="奔跑的蜗牛">
<meta property="og:description" content="剑指offer读书笔记，记录一些要注意的知识点。">
<meta property="og:updated_time" content="2016-01-31T05:30:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer 读书笔记">
<meta name="twitter:description" content="剑指offer读书笔记，记录一些要注意的知识点。">
  
    <link rel="alternative" href="/atom.xml" title="奔跑的蜗牛" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog_img/images/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog_img/images/favicon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">liangkai</a></h1>
		</hgroup>

		
		<p class="header-subtitle">每天进步一点点</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						<li>友情链接</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/lkpjj" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/lkkzm" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/liang-kai-29" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="/kevin.scnu@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Effective-C/" style="font-size: 20px;">Effective C++</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/binaryTree/" style="font-size: 10px;">binaryTree</a> <a href="/tags/c/" style="font-size: 20px;">c++</a> <a href="/tags/cmake/" style="font-size: 13.33px;">cmake</a> <a href="/tags/core-dump/" style="font-size: 10px;">core dump</a> <a href="/tags/define-const-sizeof/" style="font-size: 10px;">define  const sizeof</a> <a href="/tags/gsl/" style="font-size: 10px;">gsl</a> <a href="/tags/i/" style="font-size: 10px;">i++</a> <a href="/tags/kindle/" style="font-size: 10px;">kindle</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/list/" style="font-size: 13.33px;">list</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/opencv/" style="font-size: 13.33px;">opencv</a> <a href="/tags/pelican/" style="font-size: 10px;">pelican</a> <a href="/tags/problem/" style="font-size: 13.33px;">problem</a> <a href="/tags/pyglet/" style="font-size: 10px;">pyglet</a> <a href="/tags/python/" style="font-size: 16.67px;">python</a> <a href="/tags/queue/" style="font-size: 10px;">queue</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/stack/" style="font-size: 10px;">stack</a> <a href="/tags/system/" style="font-size: 13.33px;">system</a> <a href="/tags/tcp-ip/" style="font-size: 10px;">tcp/ip</a> <a href="/tags/thinkpad/" style="font-size: 10px;">thinkpad</a> <a href="/tags/tips/" style="font-size: 10px;">tips</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/wavelet/" style="font-size: 10px;">wavelet</a> <a href="/tags/yaourt/" style="font-size: 10px;">yaourt</a> <a href="/tags/指针/" style="font-size: 10px;">指针</a> <a href="/tags/赋值/" style="font-size: 10px;">赋值</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">liangkai</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/blog_img/images/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">liangkai</h1>
			</hgroup>
			
			<p class="header-subtitle">每天进步一点点</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/lkpjj" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/lkkzm" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/liang-kai-29" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/kevin.scnu@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-剑指offer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/23/剑指offer/" class="article-date">
  	<time datetime="2014-08-23T13:42:36.000Z" itemprop="datePublished">2014-08-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      剑指offer 读书笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/c/">c++</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
		<!-- Table of Contents -->
        
            <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u57FA_u7840_u77E5_u8BC6"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u7A7A_u7C7B_u578B_u7684sizeof"><span class="toc-number">1.1.</span> <span class="toc-text">空类型的sizeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8D4B_u503C_u8FD0_u7B97_u51FD_u6570_u5B9E_u73B0"><span class="toc-number">1.2.</span> <span class="toc-text">赋值运算函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4EE5O_28n_29_u7684_u65F6_u95F4_u6548_u7387_u5B9E_u73B0_u6392_u5E8F"><span class="toc-number">1.3.</span> <span class="toc-text">以O(n)的时间效率实现排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570"><span class="toc-number">1.4.</span> <span class="toc-text">二进制中1的个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u9AD8_u8D28_u91CF_u7684_u4EE3_u7801"><span class="toc-number">2.</span> <span class="toc-text">高质量的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u7ED3_u70B9"><span class="toc-number">2.1.</span> <span class="toc-text">链表中倒数第k个结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5B9E_u73B0_u5355_u94FE_u8868_u7684_u53CD_u8F6C"><span class="toc-number">2.2.</span> <span class="toc-text">实现单链表的反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5408_u5E76_u4E24_u4E2A_u5355_u94FE_u8868"><span class="toc-number">2.3.</span> <span class="toc-text">合并两个单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E8C_u53C9_u6811_u7684_u955C_u50CF_u5B9E_u73B0"><span class="toc-number">2.4.</span> <span class="toc-text">二叉树的镜像实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811"><span class="toc-number">2.5.</span> <span class="toc-text">从上往下打印二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E8C_u53C9_u6811_u6811_u4E0E_u53CC_u5411_u94FE_u8868"><span class="toc-number">2.6.</span> <span class="toc-text">二叉树树与双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57"><span class="toc-number">2.7.</span> <span class="toc-text">数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C"><span class="toc-number">2.8.</span> <span class="toc-text">连续子数组的最大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57"><span class="toc-number">2.9.</span> <span class="toc-text">数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u548C_u4E3As_u7684_u4E24_u4E2A_u6570_u5B57"><span class="toc-number">2.10.</span> <span class="toc-text">和为s的两个数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#n_u4E2A_u9AB0_u5B50_u7684_u70B9_u6570"><span class="toc-number">2.11.</span> <span class="toc-text">n个骰子的点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_u5B57"><span class="toc-number">2.12.</span> <span class="toc-text">圆圈中最后剩下的数字</span></a></li></ol></li></ol>
            </div>
        
        <h3 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="u7A7A_u7C7B_u578B_u7684sizeof"><a href="#u7A7A_u7C7B_u578B_u7684sizeof" class="headerlink" title="空类型的sizeof"></a>空类型的sizeof</h4><ol>
<li><span class="label label-danger">问</span>： 定义一个空类型，里面没有任何成员变量和成员函数，该类型求sizeof，得到结果是多少？<br><span class="label label-success">答</span>： 空类型的实例中不包含任何信息，本来应该是0,但当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例，至于占用多少内存，由编译器决定，一般空类型的实例占用 <strong>1字节</strong>的空间。</li>
<li><span class="label label-danger">问</span>： 在空类型中添加虚析构函数之后呢？<br><span class="label label-success">答</span>： c++编译器发现类型中存在虚函数时，就会生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，因此此时占用的空间大小应为一个指针占用的大小，在32位机器为 4字节，64位为 8字节。</li>
</ol>
<a id="more"></a>
<h4 id="u8D4B_u503C_u8FD0_u7B97_u51FD_u6570_u5B9E_u73B0"><a href="#u8D4B_u503C_u8FD0_u7B97_u51FD_u6570_u5B9E_u73B0" class="headerlink" title="赋值运算函数实现"></a>赋值运算函数实现</h4><span class="label label-success">实现</span>：<br><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyString</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">char</span>* m_pData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyString(<span class="built_in">char</span>* pData = NULL);</span><br><span class="line">	~MyString();</span><br><span class="line">	MyString(<span class="keyword">const</span> MyString&amp; <span class="built_in">str</span>);</span><br><span class="line">	MyString&amp; operator=(<span class="keyword">const</span> MyString&amp; <span class="built_in">str</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyString&amp; operator=(<span class="keyword">const</span> MyString&amp; <span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(&amp;<span class="built_in">str</span> != <span class="keyword">this</span>)  <span class="comment">//首先判断传入的对象是否是自身，只有不是自身时才进行赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyString temp(<span class="built_in">str</span>); <span class="comment">//拷贝构造一个临时对象</span></span><br><span class="line">		<span class="built_in">char</span>* pTemp = temp.m_pData; <span class="comment">//实现传入对象和临时对象数据交换</span></span><br><span class="line">		temp.m_pData = <span class="built_in">str</span>.m_pData;</span><br><span class="line">		<span class="built_in">str</span>.m_pData= pTemp;</span><br><span class="line">	&#125;<span class="comment">//当离开临时变量/对象的作用域时，临时变量/对象temp会自动调用析构函数，释放占用的内存</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4EE5O_28n_29_u7684_u65F6_u95F4_u6548_u7387_u5B9E_u73B0_u6392_u5E8F"><a href="#u4EE5O_28n_29_u7684_u65F6_u95F4_u6548_u7387_u5B9E_u73B0_u6392_u5E8F" class="headerlink" title="以O(n)的时间效率实现排序"></a>以O(n)的时间效率实现排序</h4><span class="label label-danger">题目</span>：对一个公司的几万名员工的年龄排序<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> *pArray,<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortAges</span><span class="params">(<span class="keyword">int</span> ages[],<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断传入的数组是否为空</span></span><br><span class="line">  <span class="keyword">if</span>(ages == <span class="literal">NULL</span> || length&lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>  ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxAge = <span class="number">99</span>;</span><br><span class="line">  <span class="keyword">int</span> timesOfAge[maxAge+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义统计年龄次数的数组，并且初始化</span></span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=maxAge)</span><br><span class="line">  &#123;</span><br><span class="line">    timesOfAge[i] = <span class="number">0</span>;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历数组，对年龄的次数进行统计</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;++j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> age = ages[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">0</span> || age&gt;maxAge)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"age out of range."</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ++timesOfAge[age];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;maxAge;++m)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;timesOfAge[m];++k)</span><br><span class="line">    &#123;</span><br><span class="line">      ages[index]=m;</span><br><span class="line">      ++index;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> *pArray,<span class="keyword">int</span> num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;++i)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pArray[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ages[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">70</span>,<span class="number">90</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">88</span>,<span class="number">88</span>,<span class="number">64</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">99</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(ages)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过指针传递数组</span></span><br><span class="line">  sortAges(ages,num);</span><br><span class="line">  display(ages, num);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序实现了以常量大小的辅助空间，换来了O(n)的时间效率。</p>
<h4 id="u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570"><a href="#u4E8C_u8FDB_u5236_u4E2D1_u7684_u4E2A_u6570" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h4><span class="label label-danger">题目</span>： 对于给定的十进制数，求其二进制中的1的数目<br><span class="label label-info">分析</span>： 对于统计二进制中1的个数，最常使用的方法是采用位移的方法来统计，有两个思路：<br>1. 将要统计的目标右移，与flag=1进行与运算，统计个数<br>2. 将标志位flag=1左移，与目标数进行与运算，统计个数<br>对于第一种方法，则容易导致死循环问题，因为将负数右移必须保证符号位仍为1，而导致的问题就是将目标数最终变成<strong>0xFFFFFFFF</strong>,导致死循环。<br>对于此问题可采用第二种方法<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算输入数字的二进制表示中1的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calNumOfOne</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为防止右移n导致出现死循环，采用将flag左移</span></span><br><span class="line">  <span class="keyword">while</span>(flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//与运算</span></span><br><span class="line">    <span class="keyword">if</span>(n &amp; flag)</span><br><span class="line">      ++num;</span><br><span class="line">    </span><br><span class="line">    flag = flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于该问题书中还给出了一个更新颖的解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算输入数字的二进制表示中1的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calNumOfOne</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n)</span><br><span class="line">  &#123;</span><br><span class="line">    ++num;</span><br><span class="line">    n = (n-<span class="number">1</span>) &amp; n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与位移运算的还有其他类似题目：</p>
<ol>
<li>计算一个整数是否是2的次方(如果是则二进制表示中只有一个1)</li>
</ol>
<h3 id="u9AD8_u8D28_u91CF_u7684_u4EE3_u7801"><a href="#u9AD8_u8D28_u91CF_u7684_u4EE3_u7801" class="headerlink" title="高质量的代码"></a>高质量的代码</h3><h4 id="u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u7ED3_u70B9"><a href="#u94FE_u8868_u4E2D_u5012_u6570_u7B2Ck_u4E2A_u7ED3_u70B9" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h4><span class="label label-danger">题目</span>：输入一个链表中倒数第k个结点。<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Listnode* <span class="title">countDownK</span><span class="params">(Listnode* pHead,<span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  Listnode* first = pHead;</span><br><span class="line">  Listnode* second = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;m_next != <span class="literal">NULL</span>)</span><br><span class="line">      first = first-&gt;m_next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  second = pHead;</span><br><span class="line">  <span class="keyword">while</span>(first-&gt;m_next != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    first = first-&gt;m_next;</span><br><span class="line">    second = second-&gt;m_next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><span class="label label-warning">相关题目</span>： 求链表的中间结点，如果链表中结点总数为奇数，返回中间结点;如果结点是总数为奇数，返回中间结点;如果中间结点总数是偶数，返回中间两个结点的任意一个。</li>
<li><span class="label label-warning">相关题目</span>： 判断一个单向链表是否形成了环形结构，定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两部，如果走的快的指针追上走的慢的指针，那么链表中存在环形链表，如果走的块走到末尾都没有追上第一个指针，那么链表就不是环形链表。</li>
</ol>
<h4 id="u5B9E_u73B0_u5355_u94FE_u8868_u7684_u53CD_u8F6C"><a href="#u5B9E_u73B0_u5355_u94FE_u8868_u7684_u53CD_u8F6C" class="headerlink" title="实现单链表的反转"></a>实现单链表的反转</h4><span class="label label-success">实现</span>：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* pHead)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//用于保存当前结点的前一个结点</span></span><br><span class="line">  ListNode* pPrev = <span class="built_in">NULL</span>;</span><br><span class="line">  <span class="comment">//保存当前结点</span></span><br><span class="line">  ListNode* pNode = pHead;</span><br><span class="line">  <span class="comment">//返回反转链表结点的头结点</span></span><br><span class="line">  ListNode* pReverseHead = <span class="built_in">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(pNode != <span class="built_in">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//保存当前结点的下一个结点</span></span><br><span class="line">    ListNode* pNext = pNode<span class="subst">-&gt;</span>m_next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当下一个结点不存在时，说明到达尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pNext == <span class="built_in">NULL</span>)</span><br><span class="line">      pReverseHead = pNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现反转</span></span><br><span class="line">    pNode<span class="subst">-&gt;</span>m_next = pPrev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动结点</span></span><br><span class="line">    pPrev = pNode;</span><br><span class="line">    pNode = pNext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pReverseHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5408_u5E76_u4E24_u4E2A_u5355_u94FE_u8868"><a href="#u5408_u5E76_u4E24_u4E2A_u5355_u94FE_u8868" class="headerlink" title="合并两个单链表"></a>合并两个单链表</h4><p>对于链表的合并可以采用循环或者递归两种方法，下例采用递归方法：<br><span class="label label-success">实现</span>：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> m_data;</span><br><span class="line">  ListNode* m_next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode* merge(ListNode* pFirst,ListNode* pSecond)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(pFirst == <span class="keyword">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> pSecond;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pSecond == <span class="keyword">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> pFirst;</span><br><span class="line"></span><br><span class="line">  ListNode* pMergeHead = <span class="keyword">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>(pFirst-&gt;m_data &lt; pSecond-&gt;m_data)</span><br><span class="line">  &#123;</span><br><span class="line">    pMergeHead = pFirst;</span><br><span class="line">    pMergeHead-&gt;m_next = merge(pFirst-&gt;m_next,pSecond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pMergeHead = pSecond;</span><br><span class="line">    pMergeHead-&gt;m_next = merge(pSecond,pSecond-&gt;m_next );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pMergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u4E8C_u53C9_u6811_u7684_u955C_u50CF_u5B9E_u73B0"><a href="#u4E8C_u53C9_u6811_u7684_u955C_u50CF_u5B9E_u73B0" class="headerlink" title="二叉树的镜像实现"></a>二叉树的镜像实现</h4><span class="label label-success">实现</span>：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> mirrorTree(BinaryTreeNode* pNode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//排除根节点和叶子结点</span></span><br><span class="line">  <span class="keyword">if</span>(pNode == <span class="built_in">NULL</span> <span class="subst">||</span> (pNode<span class="subst">-&gt;</span>m_left == <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> pNode<span class="subst">-&gt;</span>m_right == <span class="built_in">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//交换该结点的两个孩子结点</span></span><br><span class="line">  BinaryTreeNode* temp = pNode<span class="subst">-&gt;</span>m_left;</span><br><span class="line">  pNode<span class="subst">-&gt;</span>m_left = pNode<span class="subst">-&gt;</span>m_right;</span><br><span class="line">  pNode<span class="subst">-&gt;</span>m_right = temp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向下递归子节点</span></span><br><span class="line">  <span class="keyword">if</span>(pNode<span class="subst">-&gt;</span>m_left)</span><br><span class="line">    mirrorTree(pNode<span class="subst">-&gt;</span>m_left);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pNode<span class="subst">-&gt;</span>m_right)</span><br><span class="line">    mirrorTree(pNode<span class="subst">-&gt;</span>m_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811"><a href="#u4ECE_u4E0A_u5F80_u4E0B_u6253_u5370_u4E8C_u53C9_u6811" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h4><p>对于二叉树的打印可以采用队列作为辅助，每次在将队列出队的时候，将其子结点添加到队尾。<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(BinaryTreeNode* pNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>：:<span class="built_in">deque</span>&lt;BinaryTreeNode*&gt; tempDeque;</span><br><span class="line">  tempDeque.push_back(pNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(tempDeque.size())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//获取队列的第一个元素</span></span><br><span class="line">    BinaryTreeNode* pTop = tempDeque.front();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将队列第一个元素出队</span></span><br><span class="line">    tempDeque.pop_front();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pTop-&gt;m_data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pTop-&gt;m_left)</span><br><span class="line">      tempDeque.push_back(pTop-&gt;m_left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_right)</span><br><span class="line">      tempDeque.push_back(pTop-&gt;m_right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u4E8C_u53C9_u6811_u6811_u4E0E_u53CC_u5411_u94FE_u8868"><a href="#u4E8C_u53C9_u6811_u6811_u4E0E_u53CC_u5411_u94FE_u8868" class="headerlink" title="二叉树树与双向链表"></a>二叉树树与双向链表</h4><span class="label label-danger">题目</span>：将一个二叉树转换为双向链表<br><span class="label label-success">实现</span>：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTree</span><br><span class="line">&#123;</span><br><span class="line">  int m_data;</span><br><span class="line">  BinaryTree* m_left;</span><br><span class="line">  BinaryTree* m_right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义pLast为一个指向BinaryTree类型指针的指针，让其始终指向已经完成的双向链表的最后一个结点</span></span><br><span class="line"><span class="literal">void</span> convert(BinaryTree* pNode,BinaryTree** pLast)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(pNode == <span class="built_in">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理左子数</span></span><br><span class="line">  BinaryTree* pCurrent = pNode;<span class="comment">//当前结点</span></span><br><span class="line">  <span class="keyword">if</span>(pCurrent<span class="subst">-&gt;</span>m_left != <span class="built_in">NULL</span>)</span><br><span class="line">    convert(pCurrent<span class="subst">-&gt;</span>m_left,pLast);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//处理根结点</span></span><br><span class="line">  pCurrent<span class="subst">-&gt;</span>m_left = *pLast;<span class="comment">//将当前结点指向pLast所指向的结点</span></span><br><span class="line">  <span class="keyword">if</span>(pLast != <span class="built_in">NULL</span>)<span class="comment">//当pLast指向的结点不是非空的时候，需要将pLast指向的结点的右指针指向pCurrent</span></span><br><span class="line">    (*pLast)<span class="subst">-&gt;</span>m_right = pCurrent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当根节点链接之后，要将当前结点后移</span></span><br><span class="line">  *pLast = pCurrent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pCurrent<span class="subst">-&gt;</span>m_right != <span class="built_in">NULL</span>)</span><br><span class="line">    convert(pCurrent<span class="subst">-&gt;</span>m_right,pLast);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////更容易记的方法</span></span><br><span class="line">BinaryTree* pHead = <span class="built_in">NULL</span>;<span class="comment">//用于指向头结点</span></span><br><span class="line">BinaryTree* pIndex= <span class="built_in">NULL</span>;<span class="comment">//指向双向链表的最后一个结点</span></span><br><span class="line"><span class="literal">void</span> convertToDoubleList(BinaryTree* pCurrent)</span><br><span class="line">&#123;</span><br><span class="line">  pCurrent<span class="subst">-&gt;</span>m_left=pIndex;<span class="comment">//使当前结点的左指针指向双向链表的最后一个结点</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">NULL</span> == pIndex)<span class="comment">//若最后一个元素不存在，说明此时双向链表尚未建立，因此将当前结点设定为双向链表的头结点</span></span><br><span class="line">    pHead=pCurrent;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//使双向链表的最后一个结点的右结点指向当前结点</span></span><br><span class="line">    pIndex<span class="subst">-&gt;</span>m_right = pCurrent;</span><br><span class="line"></span><br><span class="line">  pIndex=pCurrent;<span class="comment">//将当前结点设为双向链表的最后一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="literal">void</span> inOrderBSTree(BinaryTree* pTree)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">NULL</span> == pTree)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//递归左子树</span></span><br><span class="line">  inOrderBSTree(pTree<span class="subst">-&gt;</span>m_left);</span><br><span class="line">  convertToDoubleList(pTree);</span><br><span class="line">  inOrderBSTree(pTree<span class="subst">-&gt;</span>m_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57"><a href="#u6570_u7EC4_u4E2D_u51FA_u73B0_u6B21_u6570_u8D85_u8FC7_u4E00_u534A_u7684_u6570_u5B57" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h4><span class="label label-danger">题目</span>： 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。(上次面试的时候就被问到了这个问题，应该早点看的……)。<br><span class="label label-info">分析</span>：<br>1. O(nlogn)的解法：<br>将该数组快速排序，那么排序后的数组的中间位置的数字就是想要的结果。<br>2. O(n)的解法：<br>我们可以在遍历数组的时候定义两个变量，一个用于保存数组中的数字，另一个用于保存次数;当下一个数字和当前保存的数字不同时，我们将次数减一;如果下一个出现的数字和当前保存的数字相同时，则将次数加一;当保存的次数为零时更新当前保存的数字，同时将次数赋值为一。由于我们要求的数字出现的次数比其他所有数字之和加起来都要多，因此最后的结果中保存的数字肯定就是我们要求的数字。<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[i] == num &amp;&amp; times != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++times;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[i] != num &amp;&amp; times != <span class="number">0</span>)</span><br><span class="line">      --times;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(times == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      num = <span class="built_in">array</span>[i];</span><br><span class="line">      times = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"times: "</span>&lt;&lt;times&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C"><a href="#u8FDE_u7EED_u5B50_u6570_u7EC4_u7684_u6700_u5927_u548C" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><span class="label label-danger">题目</span>：要求输出数组的子数组的和的最大值，要求时间复杂度为O(n)。<br>例如：输入数组<code>{1,-2,3,10,-4,7,2,-5}</code>和的最大子数组应为{3,10,-4,7,2}，和为18。<br><span class="label label-info">分析</span>：我们使用两个变量来辅助计算，一个用于保存累加到当前元素的和，另一个用于保存此时的最大和;当我们累加时，如果当前的累加和大于保存的最大和，则更新最大和;当当前的累加和小于等于零时，我们则抛弃之前那些已经累加的数字，而从下一个元素重新开始计算累加和，因为如果之前的累加和小于等于0,那么对于后边的累加只会造成减小的效果，所以这样理解之后可以判断出关键的条件就是：<em>只要当前的累加和大于0,那么就可以继续将后续的元素与之相加，再与保存的最大值做比较</em>，具体实现如下：<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calSum</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">NULL</span> || length &lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> lastSum = -<span class="number">999999999</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sum = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      sum += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum&gt;lastSum)</span><br><span class="line">      lastSum = sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lastSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57"><a href="#u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h4><span class="label label-danger">题目</span>： 一个整形数组里除了两个数字之外，其他数字都出现两次，请找出这个只出现一次的数字，要求时间复杂度为O(n)，空间复杂度O(1)。<br><span class="label label-info">分析</span>： 通过分析题目的特点可以知道，除了一个数字以外，其他数字出现的次数都是两次，我们可以用<strong>异或</strong>来计算，以此异或数组中的所有数字，因为当两个数字相同时，它们异或的结果为0,那么当所有的异或之后最终的结果就是那个只出现一次的数字。<br>再分析题目，发现有两个出现一次的数字，那么我们可以试着将它们分为两个部分，每个部分包含一个只出现一次的数字，然后再使用以上思路即可。<br><span class="label label-info">分析2</span>：依然从头依次异或数组，最终得到的结果就是两个只出现一次数字的异或结果，由于其他数字出现两次，所以最终保留的是这两个只出现一次的数字，由于这两个数字肯定不一样，那么总异或的结果中至少有一位为1,我们可以找出第一个1的位置，记为第n位，然后我们依据数组中每个数字的第n位是否为1将数组分为两部分.<br><span class="label label-success">实现</span>：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> findNumsAppearOnce(<span class="type">int</span> data[],<span class="type">int</span> length,<span class="type">int</span>* num1,<span class="type">int</span>* num2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(data == <span class="type">NULL</span> || length&lt;<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)</span><br><span class="line">    <span class="literal">result</span> ^=data[i];</span><br><span class="line"></span><br><span class="line">  unsigned <span class="type">int</span> indexOf1 = findFirstBit(<span class="literal">result</span>);</span><br><span class="line">  </span><br><span class="line">  *num1=<span class="number">0</span>;</span><br><span class="line">  *num2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;++j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(isBit1(data[j],indexOf1))</span><br><span class="line">    &#123;</span><br><span class="line">      *num1 ^=data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *num2 ^= data[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//找出异或结果中第一个<span class="number">1</span>的位置</span><br><span class="line">unsigned <span class="type">int</span> findFirstBit(<span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> indexBit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; indexBit &lt; <span class="number">8</span>*sizeof(<span class="type">int</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    num = num &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ++indexBit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> indexBit;  </span><br><span class="line">&#125;</span><br><span class="line">//判断数组中的第indexBit位是否为<span class="number">1</span></span><br><span class="line"><span class="type">bool</span> isBit1(<span class="type">int</span> num,unsigned <span class="type">int</span> indexBit)</span><br><span class="line">&#123;</span><br><span class="line">  num = num&gt;&gt;indexBit;</span><br><span class="line">  <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体详细解释可以参考剑指offer的228页。</p>
<h4 id="u548C_u4E3As_u7684_u4E24_u4E2A_u6570_u5B57"><a href="#u548C_u4E3As_u7684_u4E24_u4E2A_u6570_u5B57" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h4><span class="label label-danger">题目</span>： 输入一个递增排序的数组和一个数字s，在数组中查找两个数使得它们的和正好是s。如果有多对，输出任意一对即可。<br><span class="label label-info">分析</span>： 常规的方法可能是遍历实现，这样的话时间复杂度则为O(n)。另一种较为高效的方法是使用两个指针，分别指向头尾，计算两个的和，如果大于要求的s，那么就让第二个指针前移，若要求的结果小于s，则将前边的指针往后移.<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length,<span class="keyword">int</span> sum)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* begin = &amp;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span>* end = &amp;<span class="built_in">array</span>[length-<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// int sum = (*begin) + (*end);</span></span><br><span class="line">  <span class="keyword">while</span>(begin != end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = *begin;</span><br><span class="line">    <span class="keyword">int</span> num2 = *end;</span><br><span class="line">    <span class="keyword">if</span>(num1+num2 == sum)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;num1&lt;&lt;<span class="string">","</span>&lt;&lt;num2&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num1+num2&gt;sum)</span><br><span class="line">      end--;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      begin++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(begin == end)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"can't find"</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="n_u4E2A_u9AB0_u5B50_u7684_u70B9_u6570"><a href="#n_u4E2A_u9AB0_u5B50_u7684_u70B9_u6570" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h4><span class="label label-danger">题目</span>：把n个骰子扔在地上，所有骰子朝上一面的点数之和为S。输入n，打印出S的所有可能的值出现的概率。<br><span class="label label-info">分析</span>：玩过麻将的都知道，骰子一共6个面，每个面上都有一个点数，对应的数字是1到 6之间的一个数字。所以，n个骰子的点数和的最小值为n，最大值为6n。因此，一个直观的思路就是定义一个长度为6n-n的数组，和为S的点数出现的次数保存到数组第S-n个元素里。另外，我们还知道n个骰子的所有点数的排列数6^n。一旦我们统计出每一点数出现的次数之后，因此只要把每一点数出现的次数除以n^6，就得到了对应的概率。<br><br>我们可以考虑用两个数组来存储骰子点数每一总数出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。那么在下一循环中，我们加上一个新的骰子。那么此时和为n的骰子出现的次数，应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的总和。所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。<br><em>有k-1个骰子时，再增加一个骰子，这个骰子的点数只可能为1、2、3、4、5或6。那k个骰子得到点数和为n的情况有：<br>(k-1,n-1)：第k个骰子投了点数1<br>(k-1,n-2)：第k个骰子投了点数2<br>(k-1,n-3)：第k个骰子投了点数3<br>….<br>(k-1,n-6)：第k个骰子投了点数6<br>在k-1个骰子的基础上，再增加一个骰子出现点数和为n的结果只有这6种情况！<br>所以：f(k,n)=f(k-1,n-1)+f(k-1,n-2)+f(k-1,n-3)+f(k-1,n-4)+f(k-1,n-5)+f(k-1,n-6)<br>初始化：有1个骰子，f(1,1)=f(1,2)=f(1,3)=f(1,4)=f(1,5)=f(1,6)=1。 
</em><br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability_Solution2</span><span class="params">(<span class="keyword">int</span> number)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(number &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* pProbabilities[<span class="number">2</span>];</span><br><span class="line">  pProbabilities[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">  pProbabilities[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_maxValue * number + <span class="number">1</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    pProbabilities[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    pProbabilities[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g_maxValue; ++i) </span><br><span class="line">    pProbabilities[flag][i] = <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= number; ++k) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">      pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= g_maxValue * k; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">      pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j) </span><br><span class="line">        pProbabilities[<span class="number">1</span> - flag][i] += pProbabilities[flag][i - j];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    flag = <span class="number">1</span> - flag;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue, number);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = number; i &lt;= g_maxValue * number; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbabilities[flag][i] / total;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d: %e\n"</span>, i, ratio);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span>[] pProbabilities[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">delete</span>[] pProbabilities[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_u5B57"><a href="#u5706_u5708_u4E2D_u6700_u540E_u5269_u4E0B_u7684_u6570_u5B57" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h4><span class="label label-danger">题目</span>： 0,1,……n这n个数字排成一个圆圈，每次从0开始将第m个数字出队，求最终剩下的数字。<br><span class="label label-info">分析</span>： 分析题目可以知道该题目就是经典的约瑟夫环问题，我们可以采用一个环形链表来模拟圆圈，每次将链表的第m个结点删除，最终得出结果。<br><span class="label label-success">实现</span>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从0到n的环中删除第m个直到剩余最后一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemain</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n,<span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">    numbers.push_back(i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator current = numbers.begin();</span><br><span class="line">  <span class="keyword">while</span>(numbers.size()&gt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">      ++i;</span><br><span class="line">      ++current;</span><br><span class="line">      <span class="keyword">if</span>(current == numbers.end())</span><br><span class="line">        current = numbers.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存下一个位置，以便从下个位置开始继续删除第m个</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++current;</span><br><span class="line">    <span class="keyword">if</span>(next == numbers.end())</span><br><span class="line">      next = numbers.begin();</span><br><span class="line"></span><br><span class="line">    --current;</span><br><span class="line">    numbers.erase(current);</span><br><span class="line">    current=next;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (*current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2014/08/23/剑指offer/">剑指offer 读书笔记</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 liangkai 的个人博客">liangkai</a></p>
        <p><span>发布时间:</span>2014年08月23日 - 13时42分</p>
        <p><span>最后更新:</span>2016年01月31日 - 13时30分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2014/08/23/剑指offer/" title="剑指offer 读书笔记">http://liangkai.me/2014/08/23/剑指offer/</a>
            <span class="copy-path" data-clipboard-text="原文: http://liangkai.me/2014/08/23/剑指offer/　　作者: liangkai" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2014/09/02/纸上谈兵读书笔记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          纸上谈兵读书笔记
        
      </div>
    </a>
  
  
    <a href="/2014/08/19/effective_c++_31_40/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Effective C++ 读书笔记(31-40)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="剑指offer" data-title="剑指offer 读书笔记" data-url="http://liangkai.me/2014/08/23/剑指offer/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>






    <div class="scroll" id="post-nav-button">
        
            <a href="/2014/09/02/纸上谈兵读书笔记/" title="上一篇: 纸上谈兵读书笔记">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2014/08/19/effective_c++_31_40/" title="下一篇: Effective C++ 读书笔记(31-40)">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/05/03/vim学习及配置/">vim配置折腾记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/06/gsl_fft/">GNU Scientific Library -- FFT变换学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/22/c++_face_question/">C++ 面试问题汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/02/process_and_thread/">进程与线程的一个解释(转载)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/02/纸上谈兵读书笔记/">纸上谈兵读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/23/剑指offer/">剑指offer 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/19/effective_c++_31_40/">Effective C++ 读书笔记(31-40)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/19/effective_c++_21_30/">Effective C++ 读书笔记(21-30)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/18/effective_c++_11_20/">Effective C++ 读书笔记(11-20)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/16/effective_c++/">Effective C++ 读书笔记(1-10)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/09/c++_store/">C++ Primer Plus(第五版) 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/21/python_symbol_review/">python 中常见符号记载</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/18/commandlineparser/">opencv CommandLineParser类的简单理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/17/c++_memory/">c++ 中的内存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/17/vbird_reading_note/">鸟哥的linux私房菜(服务器篇)--读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/16/network/">tcp/ip第一卷:协议 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/13/system/">操作系统相关知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/11/high_quality_program/">高质量编程读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/06/gentoo/">正式转向gentoo</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/28/binarytree/">c++中的二叉树实现(memo14)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/27/sort/">c++笔试中的排序方法(memo13)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/25/stack/">c++中的栈实现(memo12)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/25/queue/">c++中的队列实现(memo11)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/22/doublelist/">c++中的双向链表实现(memo10)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/22/singlelist/">c++中的单链表实现(memo9)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/21/oop/">c++面向对象(memo8)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/20/stl/">STL模板与容器(memo7)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/19/recursion/">c++中的控制语句(memo6)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/18/demo5/">指针与数组(memo5)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/17/demo4/">define、const、sizeof(memo4)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/17/demo3/">笔试中的刁钻题目(memo3)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/17/demo2/">c语言的自加问题(memo2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/16/demo1/">赋值语句(memo1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/14/wavelet-enhancement/">matlab中小波分解介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/10/latex_cjk/">latex中使用中文</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/02/28/opencv_memory/">opencv中的内存释放</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/01/10/thinkpad/">T430 中 thinkfan以及电源阈值的控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/01/09/vtk_cmake/">VTK中Cmake文件的编写及其原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/01/08/cmake/">初识cmake</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/11/01/python-pyglet/">基于Python实现的定时闹铃</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/31/python-name/">python中__name_的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/29/python-self/">python中self的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/28/archlinux-tips/">linux中问题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/25/python-html/">python爬虫小程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/19/core-dump/">段错误问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/18/kindle-break/">Kindle paperwhite越狱</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/15/first-day-practice/">实习第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/10/14/build-blog/">用pelican搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/01/07/yaourt/">yaourt错误</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016-03-20 <a href="http://github.com/lkpjj">liangkai</a> <a href="http://liangkai.me">奔跑的蜗牛</a>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44990781-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>